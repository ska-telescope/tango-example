"""Basic custom event-based assertions for ::class::`TangoEventTracer`.

This module provides some example of basic custom ::mod::`assertpy` assertions
to be used with ::class::`TangoEventTracer` instances. These assertions can be
used to verify properties about the events captured by the tracer.

Essentially they are query calls to the tracer, within
a timeout, to check if the are events which match an expected more or less
complex predicate.

You can and you are encouraged to take those assertions as a starting point
to create more complex ones, as needed by your test cases. If you want to do
that it is suggested to check ::mod::`assertpy` documentation to understand how
to create custom assertions (https://assertpy.github.io/docs.html).

Usage example:

.. code-block:: python

    from assertpy import assert_that, add_extension
    from ska_tango_examples.tango_event_tracer.tango_event_tracer import (
        TangoEventTracer
    )
    from ska_tango_examples.tango_event_tracer.predicates_and_assertions.event_assertions import (
        exists_event
    )

    # IMPORTANT: Add the custom extension to assertpy
    add_extension(exists_event)

    # ...

    def test_event_occurs_within_timeout(sut, tracer: TangoEventTracer):

        tracer.subscribe_to_device("devname", "attrname")

        # ... do something that triggers the event

        # Check that an attr change event happens within 10 seconds
        assert_that(tracer).exists_event(
            device_name="devname",
            attribute_name="attrname",
            attribute_value="new_value",
            previous_value="old_value",
            timeout=10
        )

NOTE: Just an important note. To make assertions about the events order
- i.e., assertion which include a verification with the shape
"event1 happens before event2" (::function::`exists_event` with
::param::`previous_value` set to a specific value is an example) - we
are currently using the reception time (::attr::`ReceivedEvent.reception_time`)
as a way to compare events. It's important to remind we are dealing with
a distributed system and the reception time may be misleading in some
cases (e.g., the reception time of the event may not be the same as the
time the event was generated by the device).

We noticed that in ::class::`tango.EventData` there is a timestamp
which tells when the Tango server received the event. Maybe in the future
it would be better to use that instead of the reception time as a way to
compare events (if it comes from a centralized server and not from the
device itself, because it is important to remember that in distributed
systems the devices clocks may not be perfectly synchronized).
"""


from typing import Optional, Union

from ska_tango_examples.tango_event_tracer.predicates_and_assertions.predicates import (
    ANY,
    event_has_previous_value,
    event_matches_parameters,
)
from ska_tango_examples.tango_event_tracer.tango_event_tracer import (
    TangoEventTracer,
)


def _get_tracer(self):
    """Get the ::class::`TangoEventTracer` instance from the assertpy context.

    Helper method to get the ::class::`TangoEventTracer` instance from the
    assertpy context or raise an error if it is not found.

    :param self: The assertpy context object.

    :return: The ::class::`TangoEventTracer` instance.

    :raises ValueError: If the ::class::`TangoEventTracer` instance is not found.
    """

    if not hasattr(self, "val") or not isinstance(self.val, TangoEventTracer):
        raise ValueError(
            "The TangoEventTracer instance must be stored in the 'val' attribute"
            " of the assertpy context. Try using the 'assert_that' method with"
            " the TangoEventTracer instance as argument.\n"
            "Example: assert_that(tracer).exists_event(...)"
        )
    return self.val


def within_timeout(self, timeout: Union[int, float]):
    """Decorator to add a timeout to an event-based assertion function.

    A timeout is a maximum wait time in seconds for the event to occur
    from the moment the assertion is called. If the event will not occur
    within this time, the assertion will fail. If no timeout is provided,
    the assertion will consieder only already existing events
    (i.e., there will be no waiting)

    :param timeout: The time in seconds to wait for the event to occur.

    :return: The decorated assertion context.

    :raises ValueError: If the ::class::`TangoEventTracer` instance is not found
        (i.e., the assertion is not called with a tracer instance).
    """

    # verify the tracer is stored in the assertpy context or raise an error
    _get_tracer(self)

    # add the timeout to the assertion
    self.event_timeout = timeout

    return self


def exists_event(
    self,
    device_name: Optional[str] = ANY,
    attribute_name: Optional[str] = ANY,
    attribute_value: Optional[any] = ANY,
    previous_value: Optional[any] = ANY,
):
    """Custom assertpy assertion to verify that an event matching a given
    predicate occurs within a specified timeout.

    :param device_name: The device name to match. If not provided, it will
        match any device name.
    :param attribute_name: The attribute name to match. If not provided, it will
        match any attribute name.
    :param attribute_value: The current value to match. If not provided, it will
        match any current value.
    :param previous_value: The previous value to match. If not provided, it will
        match any previous value.
    :param timeout: A maximum wait time in seconds for the event to occur
        from the moment the assertion is called. If the event will not occur
        within this time, the assertion will fail. If no timeout is provided,
        the assertion will consieder only already existing events
        (i.e., there will be no waiting)
    """

    # check self has a tracer object
    if not hasattr(self, "val") or not isinstance(self.val, TangoEventTracer):
        raise ValueError(
            "The TangoEventTracer instance must be stored in the 'val' attribute"
            " of the assertpy context. Try using the 'assert_that' method with"
            " the TangoEventTracer instance as argument.\n"
            "Example: assert_that(tracer).exists_event(...)"
        )

    tracer = self.val

    # query and check if any event matches the predicate
    result = tracer.query_events(
        lambda e:
        # the event match passed values
        event_matches_parameters(
            target_event=e,
            device_name=device_name,
            attribute_name=attribute_name,
            attribute_value=attribute_value,
        )
        and (
            # if given a previous value, the event must have a previous
            # event and tue previous value must match
            event_has_previous_value(
                target_event=e, tracer=tracer, previous_value=previous_value
            )
            if previous_value is not ANY
            else True
        ),
        # if given use the timeout, else None
        timeout=getattr(self, "event_timeout", None),
    )

    # if no event is found, raise an error
    if len(result) == 0:
        event_list = "\n".join([str(event) for event in tracer.events])
        msg = "Expected to find an event matching the predicate"
        if self.event_timeout is not None:
            msg += f" within {self.event_timeout} seconds"
        else:
            msg += " in already existing events"
        msg += f", but none was found. Existing events:\n{event_list}"
        self.error(msg)

    return self


def not_exists_event(
    self,
    device_name: Optional[str] = ANY,
    attribute_name: Optional[str] = ANY,
    attribute_value: Optional[any] = ANY,
    previous_value: Optional[any] = ANY,
):
    """Custom assertpy assertion to verify that an event matching a given
    predicate does not occur within a specified timeout.

    :param device_name: The device name to match. If not provided, it will
        match any device name.
    :param attribute_name: The attribute name to match. If not provided, it will
        match any attribute name.
    :param attribute_value: The current value to match. If not provided, it will
        match any current value.
    :param previous_value: The previous value to match. If not provided, it will
        match any previous value.
    :param timeout: A maximum wait time in seconds for the event to occur
        from the moment the assertion is called. If the event will not occur
        within this time, the assertion will fail. If no timeout is provided,
        the assertion will consieder only already existing events
        (i.e., there will be no waiting)
    """

    # check self has a tracer object
    if not hasattr(self, "val") or not isinstance(self.val, TangoEventTracer):
        raise ValueError(
            "The TangoEventTracer instance must be stored in the 'val' attribute"
            " of the assertpy context. Try using the 'assert_that' method with"
            " the TangoEventTracer instance as argument.\n"
            "Example: assert_that(tracer).exists_event(...)"
        )

    tracer = self.val

    # query and check if any event matches the predicate
    result = tracer.query_events(
        lambda e:
        # the event match passed values
        event_matches_parameters(
            target_event=e,
            device_name=device_name,
            attribute_name=attribute_name,
            attribute_value=attribute_value,
        )
        and (
            # if given a previous value, the event must have a previous
            # event and tue previous value must match
            event_has_previous_value(
                target_event=e, tracer=tracer, previous_value=previous_value
            )
            if previous_value is not ANY
            else True
        ),
        # if given use the timeout, else None
        timeout=getattr(self, "event_timeout", None),
    )

    # if any event is found, raise an error
    if len(result) > 0:
        msg = "Expected to not find an event matching the predicate"
        if self.event_timeout is not None:
            msg += f" within {self.event_timeout} seconds"
        else:
            msg += " in already existing events"
        msg += ", but some were found."
        msg += " Events that matched the predicate:\n"
        msg += "\n".join([str(event) for event in result])
        msg += "\n\n All existing events:\n"
        msg += "\n".join([str(event) for event in tracer.events])

        self.error(msg)


# def assert_two_events_in_order_with_timeout(tracer: TangoEventTracer, first_event_predicate, second_event_predicate, timeout):
#     """
#     Custom assertpy assertion to verify that two specific events occur in the given order within a specified timeout.

#     Args:
#         tracer (TangoEventTracer): The TangoEventTracer instance to query for events.
#         first_event_predicate (Callable[[Dict[str, any]], bool]): A predicate function for the first event.
#         second_event_predicate (Callable[[Dict[str, any]], bool]): A predicate function for the second event.
#         timeout (int): The time window in seconds to wait for the events.

#     This assertion checks if two events that satisfy the provided predicates occur in order within the given timeout period.
#     If the events do not occur in the expected order within the timeout, it lists the existing events and raises an assertion error.

#     Example Usage:
#         assert_that(tracer).assert_two_events_in_order_with_timeout(
#             lambda e: e['device'] == 'device1',
#             lambda e: e['device'] == 'device2',
#             10
#         )

#     This checks that an event from 'device1' occurs before an event from 'device2' within 10 seconds.
#     """

#     def _assertion(self):
#         start_time = time.time()
#         first_event_occurred = False

#         while time.time() - start_time < timeout:
#             with tracer.lock:
#                 if not first_event_occurred and any(first_event_predicate(event) for event in tracer.events):
#                     first_event_occurred = True

#                 if first_event_occurred and any(second_event_predicate(event) for event in tracer.events):
#                     return

#             time.sleep(0.1)  # Sleep to prevent high CPU usage

#         event_list = "\n".join([str(event) for event in tracer.events])
#         self.error(f"Expected to find two events in order within {timeout} seconds, but they were not found. Existing events:\n{event_list}")

#     return _assertion

# # Add the custom extension to assertpy
# add_extension(assert_two_events_in_order_with_timeout)
